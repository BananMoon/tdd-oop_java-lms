# 학습 관리 시스템(Learning Management System)
## Step3. 수강 신청(DB 적용)
### 구현 내용 정리
- `SessionService` 추상 클래스를 extends하는 `FreeSessionService`, `PaidSessionService` 구현체와 <br>`SessionRepository` 인터페이스를 implements하는 `FreeSessionRepository`, `PaidSessionRepository` 구현체를 추가하였습니다.
- `SessionService`를 호출하는 클라이언트에서 `SessionFeeStatus` 필드에 따라 `SessionService` 구현체를 주입받을 수 있도록 `SessionFactory`를 추가하였습니다.
- `schema.sql` :
  - `Session` 추상 클래스와 하위 클래스의 상속 관계를 테이블에서는 조인 전략으로 구성하였습니다.
  - `Course`와 `Session` 간 1:N 관계는 sessions 테이블에 course_id (FK)를 두도록 구성하였습니다.
  - `Image`와 `Session` 간 1:1 관계는 image 테이블에 session_id (FK)를 두도록 구성하였습니다.

> 핵심 학습 목표
- 2단계에서 구현한 객체 구조를 가능한 유지하면서 DB 테이블과 매핑한다.
- 성능보다 도메인 객체에 로직 구현하는 것을 목표로 연습한다.
  - 객체 구조를 유지하기 위해 여러 번의 DB 쿼리를 실행해도 괜찮다.

> 프로그래밍 요구사항
- DB 테이블과 매핑하고, 데이터를 저장한다.
  - CRUD 쿼리/코드를 구현하는 것보다 테이블을 설계하고 객체 매핑하는 부분에 집중한다.
- Payment는 테이블 매핑 시 고려하지 않는다.

> 참고<br>
샘플 데이터를 추가하고 싶다면 src/main/resources/data.sql 파일에 추가한다.<br>
CRUD 코드는 JdbcCourseRepository 참고하기<br>
CRUD 코드의 테스트 코드는 CourseRepositoryTest.


## Step2. 수강 신청(도메인 모델)
### 기능 요구사항 
- 과정 (Course)
  - 과정은 기수 단위로 운영한다.  -> 기수 `Integer cohort` 필드 생성
  - 여러 개의 강의(Session)를 가질 수 있다.  -> N개의 강의 `List<Session> sessions` 필드 생성

- 강의 (Session)
  - 필드 : 강의 제목
  - 필드 : 시작일, 종료일
  - 필드 : 강의 커버 이미지 정보 -> 별도 클래스 분리 `Image`
    - [x] 크기는 1MB 이하여야 한다.
    - [x] 타입은 gif, jpg(jpeg 포함), png, svg만 허용한다.
    - [x] width는 300픽셀, height는 200픽셀 이상이어야 한다.
    - [x] width와 height의 비율은 3:2여야 한다.
  - 필드 : 강의 최대 수강 인원
  - 필드 : 비용 지불 여부 -> Enum 분리 `SessionFeeStatus`
    - 상태 : 무료 강의, 유료 강의
    - 무료 강의는 최대 수강 인원 제한이 없다.
    - [x] 유료 강의는 강의 최대 수강 인원을 초과할 수 없다.
    - [x] 유료 강의는 수강생이 결제한 금액과 수강료가 일치할 때 수강 신청이 가능하다.
    - 유료 강의의 경우 결제는 이미 완료한 것으로 가정하고 이후 과정을 구현한다.
      - 결제를 완료한 결제 정보는 payments 모듈을 통해 관리되며, 결제 정보는 Payment 객체에 담겨 반한된다.
  - 필드 : 강의 상태 -> Enum 분리 `SessionStatus`
    - 상태: 준비중, 모집중, 종료 3가지 상태`
    - [x] 강의 수강신청은 강의 상태가 모집중일 때만 가능하다.
- 수강생 `NsStudent`
  - 수강신청한 학생 클래스로, 본인이 신청한 강의들(`sessions`)을 필드로 갖는다. 

## Step1. 레거시 코드 리팩터링
### 구현 내용 정리
- 객체의 상태를 확인/수정하는 getter/setter는 삭제한다. (기존 테스트 코드에서 사용하고 있는 getter는 유지하였습니다.)
- List 타입으로 대부분 전달/사용되는 Answer 객체를 일급 컬렉션으로 생성한다. -> `Answers`
- 객체를 삭제하고 삭제 이력을 생성하는 역할을 각 도메인에서 수행하도록 한다.
- 도메인들의 공통 필드들을 베이스 역할을 하는 추상 클래스로 추출하여 인스턴스 필드를 최소화한다. -> `BaseEntity`

### 질문 삭제하기 요구사항
- 질문글 (`Question`) 삭제
  - [x] 질문 데이터를 삭제한다. (완전 삭제가 아닌, 데이터의 상태 변경) 
  - [x] 로그인한 사용자와 질문자가 다르면 질문글 삭제할 수 없다.
- 답변 (`Answer`) 삭제
  - [x] 질문자와 답변자가 다른 경우 답변을 삭제할 수 없다. (질문자와 답변자가 같은 경우 삭제할 수 있다.)
  - [x] 질문을 삭제할 때 답변 또한 삭제한다. (완전 삭제가 아닌, 데이터의 상태 변경)
- 질문, 답변 삭제 이력 (DeleteHistory)
  - [x] `DeleteHistory` 객체를 활용해 질문, 답변 삭제 이력 정보를 남긴다.

### 리팩터링 요구사항
- QnaService의 `deleteQuestion()` 메서드에 단위 테스트 가능한 핵심 비즈니스 로직을 도메일 모델 객체에 구현한다.
- QnaService의 비지니스 로직을 도메인 모델로 이동하는 리팩터링을 진행할 때 TDD로 구현한다.
- QnaServiceTest 의 모든 테스트는 리팩터링 진행 후에도 통과해야 한다.

---
## 객체지향 생활 체조 원칙을 통한 의식적인 연습
- 규칙1: 한 메서드에 오직 한 단계의 들여쓰기(indent)만 한다. 
- 규칙 2: else 예약어를 쓰지 않는다.
- **규칙 3: 모든 원시값과 문자열을 포장한다.**
- 규칙 4: 한 줄에 점을 하나만 찍는다.
- 규칙 5: 줄여쓰지 않는다(축약 금지).
- 규칙 6: 모든 엔티티를 작게 유지한다.
- **규칙 7: 3개 이상의 인스턴스 변수를 가진 클래스를 쓰지 않는다.**
- **규칙 8: 일급 콜렉션을 쓴다.**
- **규칙 9: 게터/세터/프로퍼티를 쓰지 않는다.**
